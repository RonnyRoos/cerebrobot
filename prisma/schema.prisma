/// Prisma schema for LangGraph AsyncPostgresSaver checkpointing.
/// Models will be added in later tasks once the LangGraph structures are mapped.

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

model LangGraphCheckpoint {
  id                 String   @id @map("id")
  threadId           String   @map("thread_id")
  checkpointNamespace String  @map("checkpoint_ns")
  checkpointId       String   @map("checkpoint_id")
  parentCheckpointId String?  @map("parent_checkpoint_id")
  checkpointData     Bytes    @map("checkpoint")
  metadata           Bytes    @map("metadata")
  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")
  writes             LangGraphCheckpointWrite[]

  @@unique([threadId, checkpointNamespace, checkpointId], name: "checkpoint_lookup")
}

model LangGraphCheckpointWrite {
  id                  String               @id @default(uuid()) @map("id")
  threadId            String               @map("thread_id")
  checkpointNamespace String               @map("checkpoint_ns")
  checkpointId        String               @map("checkpoint_id")
  taskId              String               @map("task_id")
  writeIndex          Int                  @map("write_index")
  channel             String               @map("channel")
  value               Bytes                @map("value")
  createdAt           DateTime             @default(now()) @map("created_at")
  checkpoint          LangGraphCheckpoint  @relation(fields: [threadId, checkpointNamespace, checkpointId], references: [threadId, checkpointNamespace, checkpointId], onDelete: Cascade)

  @@unique([threadId, checkpointNamespace, checkpointId, taskId, writeIndex], name: "write_lookup")
  @@index([threadId, checkpointNamespace, checkpointId], name: "write_checkpoint_lookup")
}

/// Long-term memory models (Phase 2)
model User {
  id        String    @id @default(uuid())
  name      String
  deletedAt DateTime? @map("deleted_at") // Soft delete: null = active, non-null = deleted
  createdAt DateTime  @default(now()) @map("created_at")

  @@map("users")
}

model Memory {
  id        String   @id @default(uuid())
  namespace String[]
  key       String
  content   String   @db.Text
  metadata  Json?
  embedding Unsupported("vector(1536)")?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([namespace, key])
  @@index([namespace, createdAt(sort: Desc)]) // For listing memories by recency
  @@map("memories")
}

/// Thread metadata (Phase 1.5 - Multi-agent support)
/// Stores application-level thread metadata for agent selection
/// LangGraph conversation state stored separately in LangGraphCheckpoint tables
model Thread {
  id        String   @id @default(uuid())
  agentId   String   @map("agent_id") // References config/agents/{agentId}.json
  userId    String?  @map("user_id") // Optional user association (for future features)
  createdAt DateTime @default(now()) @map("created_at")

  @@index([agentId]) // For querying threads by agent
  @@index([userId]) // For querying threads by user
  @@map("threads")
}

/// Events & Effects Architecture (Spec 008)
/// Event: Immutable user message input
model Event {
  id         String   @id @default(uuid()) @db.Uuid
  sessionKey String   @map("session_key")
  seq        Int
  type       String   // 'user_message' (spec 008), extensible for spec 009
  payload    Json     // { text: string } for user_message
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz

  @@unique([sessionKey, seq])
  @@index([sessionKey, seq])
  @@map("events")
}

/// Effect: Agent response awaiting delivery (transactional outbox pattern)
model Effect {
  id            String    @id @default(uuid()) @db.Uuid
  sessionKey    String    @map("session_key")
  checkpointId  String    @map("checkpoint_id")
  type          String    // 'send_message' (spec 008), extensible for spec 009
  payload       Json      // { content: string } for send_message
  dedupeKey     String    @unique @map("dedupe_key")
  status        String    @default("pending") // pending|executing|completed|failed
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt     DateTime  @updatedAt @map("updated_at") @db.Timestamptz
  attemptCount  Int       @default(0) @map("attempt_count")
  lastAttemptAt DateTime? @map("last_attempt_at") @db.Timestamptz

  @@index([status, createdAt], map: "idx_effects_status_created")
  @@index([sessionKey])
  @@map("effects")
}
