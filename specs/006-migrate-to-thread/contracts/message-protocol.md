# WebSocket Message Protocol Specification

**Feature**: 006-migrate-to-thread  
**Date**: October 11, 2025  
**Phase**: 1 (Design - Contracts)

## Overview

This document specifies the JSON message protocol for thread-persistent WebSocket connections. It extends the existing protocol (from spec 005) with requestId fields for multiplexing and adds a cancellation event type.

---

## Protocol Principles

1. **Backward Compatibility** (FR-006): Existing event types (token/final/error) unchanged; only additive changes
2. **Request Correlation** (FR-004, FR-005): Every message includes requestId; server echoes in all responses
3. **JSON Text Frames**: All messages are JSON-encoded text frames (no binary)
4. **No Protocol Versioning** (Clarification Q5): No version field; breaking changes use new endpoint paths
5. **1MB Message Limit**: Enforced at Fastify WebSocket layer (existing constraint from spec 005)

---

## Client → Server Messages

### 1. Chat Message

**Description**: User sends a message to the chatbot

**Schema**:
```typescript
{
  type: 'message',
  requestId: string,  // NEW: UUID v4 generated by client
  threadId: string,
  content: string,
}
```

**Fields**:
- `type`: Literal string `'message'`
- `requestId`: UUID v4 generated via `crypto.randomUUID()`; unique per message
- `threadId`: Thread identifier (matched to connection's threadId)
- `content`: User's message text; max length TBD (enforce 1MB total payload limit)

**Example**:
```json
{
  "type": "message",
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "threadId": "thread-abc123",
  "content": "What is the capital of France?"
}
```

**Validation**:
- `type` must be `'message'`
- `requestId` must be valid UUID v4 string
- `threadId` must match connection's thread (server verifies)
- `content` must be non-empty string

**Processing**:
- Server extracts requestId and echoes in all response events
- Server creates AbortController for cancellation support
- Server stores activeRequestId in Connection State

---

### 2. Cancellation Signal

**Description**: Client requests cancellation of in-progress response (NEW in this spec)

**Schema**:
```typescript
{
  type: 'cancel',
  requestId: string,  // UUID of request to cancel
}
```

**Fields**:
- `type`: Literal string `'cancel'`
- `requestId`: UUID of the request to abort (matches a previous message's requestId)

**Example**:
```json
{
  "type": "cancel",
  "requestId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Validation**:
- `type` must be `'cancel'`
- `requestId` must be valid UUID string

**Processing** (FR-008, FR-009, FR-010):
- Server checks if requestId matches activeRequestId in Connection State
- If match: call `abortController.abort()`, send cancellation acknowledgment
- If no match (already completed): noop gracefully, no error
- Clear activeRequestId and abortController from Connection State

---

## Server → Client Events

### 3. Token Event (Streaming)

**Description**: Incremental content token during response streaming (MODIFIED: add requestId)

**Schema**:
```typescript
{
  type: 'token',
  requestId: string,  // NEW: Echoed from client's message
  token: string,
}
```

**Fields**:
- `type`: Literal string `'token'`
- `requestId`: UUID echoed from original message request
- `token`: Single content chunk (character, word, or sentence fragment)

**Example**:
```json
{
  "type": "token",
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "token": "Paris"
}
```

**Backward Compatibility**: Adds `requestId` field; existing token parsing logic unchanged

---

### 4. Final Event (Completion)

**Description**: Response streaming complete (MODIFIED: add requestId)

**Schema**:
```typescript
{
  type: 'final',
  requestId: string,  // NEW: Echoed from client's message
  response: {
    content: string,
    metadata: {
      tokensUsed: number,
      latencyMs: number,
    },
  },
}
```

**Fields**:
- `type`: Literal string `'final'`
- `requestId`: UUID echoed from original message request
- `response.content`: Complete response text (accumulated tokens)
- `response.metadata`: Usage statistics and latency

**Example**:
```json
{
  "type": "final",
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "response": {
    "content": "Paris is the capital of France.",
    "metadata": {
      "tokensUsed": 42,
      "latencyMs": 1250
    }
  }
}
```

**Backward Compatibility**: Adds `requestId` field; existing final event handling unchanged

---

### 5. Error Event

**Description**: Error occurred during request processing (MODIFIED: add requestId)

**Schema**:
```typescript
{
  type: 'error',
  requestId: string,  // NEW: Echoed from client's message
  error: {
    code: string,
    message: string,
    retryable: boolean,
  },
}
```

**Fields**:
- `type`: Literal string `'error'`
- `requestId`: UUID echoed from original message request (if available; may be null for connection-level errors)
- `error.code`: Machine-readable error code (e.g., `'AGENT_ERROR'`, `'RATE_LIMIT'`)
- `error.message`: Human-readable error description
- `error.retryable`: Whether user can retry (true = network/transient, false = validation/permanent)

**Error Classification Rules** (for FR-015 "clear user feedback"):

**Retryable Errors** (`retryable: true`):
- Network failures: Connection lost during streaming, ECONNREFUSED, ETIMEDOUT
- WebSocket close codes: 1006 (abnormal closure), 1001 (going away - server restart)
- Transient server errors: LangGraph timeout, rate limit (if implemented)
- Rule: User can immediately retry the same message; likely to succeed after brief wait

**Non-Retryable Errors** (`retryable: false`):
- Validation errors: Invalid threadId, malformed message, missing required fields
- WebSocket close codes: 1008 (policy violation - thread mismatch), 1003 (unsupported data)
- Permanent failures: Thread not found, user unauthorized (when auth added)
- Rule: User must fix input or check system state before retrying

**Example**:
```json
{
  "type": "error",
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "error": {
    "code": "AGENT_ERROR",
    "message": "LangGraph stream failed",
    "retryable": true
  }
}
```

**Backward Compatibility**: Adds `requestId` field; existing error handling unchanged

---

### 6. Cancellation Acknowledgment (NEW)

**Description**: Server confirms successful cancellation of request

**Schema**:
```typescript
{
  type: 'cancelled',
  requestId: string,  // UUID of cancelled request
}
```

**Fields**:
- `type`: Literal string `'cancelled'`
- `requestId`: UUID of the request that was cancelled

**Example**:
```json
{
  "type": "cancelled",
  "requestId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Processing**:
- Client removes requestId from inflightRequests Map
- Client sets isStreaming = false
- Client can now send new message

---

## Request/Response Correlation Flow

**Scenario**: User sends message, receives streaming response, sends new message mid-stream (cancellation)

```
Client                              Server
  │                                   │
  ├──► { type: 'message',             │  Generate requestId: req-1
  │      requestId: 'req-1',          │
  │      content: 'Tell me a story' } │
  │                                   ├──► Start LangGraph stream
  │                                   │    Store activeRequestId = 'req-1'
  │                                   │    Create AbortController
  │ ◄──┤ { type: 'token',             │
  │      requestId: 'req-1',          │
  │      token: 'Once upon' }         │
  │                                   │
  │ ◄──┤ { type: 'token',             │
  │      requestId: 'req-1',          │
  │      token: ' a time' }           │
  │                                   │
  ├──► { type: 'cancel',              │  User interrupts with new message
  │      requestId: 'req-1' }         │
  │                                   ├──► abortController.abort()
  │                                   │    Clear activeRequestId
  │ ◄──┤ { type: 'cancelled',         │
  │      requestId: 'req-1' }         │
  │                                   │
  ├──► { type: 'message',             │  Generate new requestId: req-2
  │      requestId: 'req-2',          │
  │      content: 'Summarize' }       │
  │                                   ├──► Start new stream
  │                                   │    Store activeRequestId = 'req-2'
  │ ◄──┤ { type: 'token',             │
  │      requestId: 'req-2',          │
  │      token: 'Summary' }           │
  │                                   │
  │ ◄──┤ { type: 'final',             │
  │      requestId: 'req-2',          │
  │      response: {...} }            │
  │                                   │
```

**Key Observations**:
- Each message gets unique requestId (req-1, req-2)
- Server echoes requestId in every event (token, final, cancelled)
- Client matches responses via requestId (handles multiplexing)
- Cancellation explicitly acknowledged before new request begins

---

## Error Scenarios

### Orphaned Response (Client-Side)

**Scenario**: Server sends event for unknown requestId (e.g., duplicate final after cancellation race condition)

**Client Behavior**:
```typescript
const handler = inflightRequests.current.get(requestId);
if (!handler) {
  console.error(`Orphaned response for requestId: ${requestId}`);
  return; // Ignore event
}
```

**No crash, no exception** - graceful degradation per edge case spec

### Cancellation After Completion (Server-Side)

**Scenario**: Client sends cancel signal after response naturally completed (race condition)

**Server Behavior**:
```typescript
const state = connectionManager.get(connectionId);
if (state.activeRequestId !== requestId) {
  // Request already completed or different request active
  return; // Noop, don't send duplicate cancelled event
}
```

**Idempotent cancellation** - no error, no duplicate acknowledgment per FR-010

---

## Protocol Evolution Strategy

**No Per-Message Versioning** (Clarification Q5): Breaking changes will use new WebSocket endpoint paths

**Additive Changes** (Current Approach):
- ✅ Adding `requestId` field: Backward compatible (existing clients ignore; new clients required)
- ✅ Adding `cancelled` event type: Backward compatible (old clients don't send cancel)

**Breaking Changes** (Future):
- Change event structure (e.g., rename `token` to `chunk`)
- Change authentication mechanism
- **Solution**: New endpoint `/api/chat/ws/v2` with new protocol; maintain `/api/chat/ws` for old clients

**Migration Path**:
- Clients detect server version via initial handshake (future work)
- Gradual rollout: old and new endpoints coexist
- Deprecation notice: log warnings when old endpoint used

---

## TypeScript Schema Definitions

**Shared Types** (packages/chat-shared/src/schemas/):

```typescript
// connection.ts (NEW)
export interface ChatMessage {
  type: 'message';
  requestId: string;
  threadId: string;
  content: string;
}

export interface CancellationSignal {
  type: 'cancel';
  requestId: string;
}

export type ClientMessage = ChatMessage | CancellationSignal;

// chat.ts (MODIFIED)
export interface TokenEvent {
  type: 'token';
  requestId: string; // NEW
  token: string;
}

export interface FinalEvent {
  type: 'final';
  requestId: string; // NEW
  response: {
    content: string;
    metadata: {
      tokensUsed: number;
      latencyMs: number;
    };
  };
}

export interface ErrorEvent {
  type: 'error';
  requestId: string; // NEW
  error: {
    code: string;
    message: string;
    retryable: boolean;
  };
}

export interface CancelledEvent {
  type: 'cancelled'; // NEW
  requestId: string;
}

export type ServerEvent = TokenEvent | FinalEvent | ErrorEvent | CancelledEvent;
```

**Zod Schemas** (for runtime validation):

```typescript
import { z } from 'zod';

export const chatMessageSchema = z.object({
  type: z.literal('message'),
  requestId: z.string().uuid(),
  threadId: z.string().min(1),
  content: z.string().min(1),
});

export const cancellationSignalSchema = z.object({
  type: z.literal('cancel'),
  requestId: z.string().uuid(),
});

export const clientMessageSchema = z.union([
  chatMessageSchema,
  cancellationSignalSchema,
]);

// Server events...
export const tokenEventSchema = z.object({
  type: z.literal('token'),
  requestId: z.string().uuid(),
  token: z.string(),
});

// ... (similar for final, error, cancelled)
```

---

## Message Protocol Specification Complete ✅

All message types defined with schemas, examples, validation rules, and error handling.

**Next**: connection-lifecycle.md (connection establishment, reconnection, cleanup flows)
